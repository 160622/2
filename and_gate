#and_gate
import numpy as np

# Input features
input_features = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])
print("Input features shape:", input_features.shape)

# Target outputs for NAND gate
target_output = np.array([1, 1, 1, 0])
print("Target output shape:", target_output.shape)
print("Target output:", target_output)

# Initialize weights and bias
weights = np.array([0.1, 0.2])
print("Initial weights:", weights)
bias = 0.3

# Learning rate
lr = 0.1

# Training loop
for epoch in range(10000):
    total_error = 0
    for inputs, label in zip(input_features, target_output):
        # Feedforward
        weighted_sum = np.dot(inputs, weights) + bias
        output = np.tanh(weighted_sum) # Inlined tanh

        # Error
        error = label - output
        total_error += abs(error)

        # Weight update using derivative of tanh (inlined)
        delta = error * (1 - output**2)
        weights += lr * delta * inputs
        bias += lr * delta

    if total_error < 0.01:
        break

# Final weights and bias
print("Final weights:", weights)
print("Final bias:", bias)

# Testing
print("Testing the trained perceptron (using threshold at 0.5):")
for inputs, label in zip(input_features, target_output):
    weighted_sum = np.dot(inputs, weights) + bias
    output = np.tanh(weighted_sum) # Inlined tanh
    predicted_label = 1 if output >= 0.5 else 0
    print(f"Input: {inputs}, Predicted Output: {predicted_label}, Target Output: {label}")
